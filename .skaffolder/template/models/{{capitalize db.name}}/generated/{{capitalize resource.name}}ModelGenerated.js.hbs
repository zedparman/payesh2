**** PROPERTIES SKAFFOLDER ****
{
    "forEachObj": "resource",
    "overwrite": true,
    "_partials": []
}
**** END PROPERTIES SKAFFOLDER ****
/**
 * 
 * 
  _____                      _              _ _ _     _   _     _        __ _ _      
 |  __ \                    | |            | (_) |   | | | |   (_)      / _(_) |     
 | |  | | ___    _ __   ___ | |_    ___  __| |_| |_  | |_| |__  _ ___  | |_ _| | ___ 
 | |  | |/ _ \  | '_ \ / _ \| __|  / _ \/ _` | | __| | __| '_ \| / __| |  _| | |/ _ \
 | |__| | (_) | | | | | (_) | |_  |  __/ (_| | | |_  | |_| | | | \__ \ | | | | |  __/
 |_____/ \___/  |_| |_|\___/ \__|  \___|\__,_|_|\__|  \__|_| |_|_|___/ |_| |_|_|\___|
 
 * DO NOT EDIT THIS FILE!! 
 * 
 *  TO CUSTOMIZE {{resource.name}}ModelGenerated.js PLEASE EDIT ../{{resource._entity.name}}Model.js
 * 
 *  -- THIS FILE WILL BE OVERWRITTEN ON THE NEXT SKAFFOLDER'S CODE GENERATION --
 * 
 */
// Database
import Database from "../../../classes/Database_{{capitalize db.name}}";
import Sequelize from "sequelize";{{#equal resource.name 'User'}}
import RolesModel from "../RolesModel";{{/equal}}

// Logger
import Logger from "../../../classes/Logger";

const generatedModel = {

  // Start queries
    
  {{#notNull resource._entity}}

  // CRUD METHODS

  {{#each resource._services}}
    {{#equal crudAction 'list'}}

  /**
  * {{../resource.name}}Model.{{name}}{{#notEmpty description}}
  *   @description {{description}}{{/notEmpty}}{{#each _params}}
  *   @param {{type}} {{name}}{{#notEmpty description}} {{description}}{{/notEmpty}}{{/each}}{{#notEmpty returnType}}
  *   @returns {{returnType}}{{/notEmpty}}
  *
  */
  async {{name}}() { {{#notEqual ../resource._entity.name "User"}}
    return await Database.getConnection().models.{{../resource.name}}.findAll();
    {{/notEqual}}{{#equal ../resource._entity.name "User"}}
    let list = await Database.getConnection().models.User.findAll(
      {
        raw: true
      },
      {
        attributes: {
          exclude: ["password"]
        }
      }
    );

    // Find roles
    for (let i in list) {
      let roles = await Database.getConnection().models.Roles.findAll({
        where: {
          _user: list[i]._id
        },
        raw: true
      });
      list[i].roles = roles.map(item => item.role);
    }

    return list;
    {{/equal}}
  },
    {{/equal}}
    {{#equal crudAction 'get'}}

  /**
  * {{../resource.name}}Model.{{name}}{{#notEmpty description}}
  *   @description {{description}}{{/notEmpty}}{{#each _params}}
  *   @param {{type}} {{name}}{{#notEmpty description}} {{description}}{{/notEmpty}}{{/each}}{{#notEmpty returnType}}
  *   @returns {{returnType}}{{/notEmpty}}
  *
  */
  async {{name}}(id) {
    let result = await Database.getConnection().models.{{../resource.name}}.findByPk(id{{#equal ../resource._entity.name "User"}}, {
      attributes: {
        exclude: ["password"]
      }
    }{{/equal}});{{#each ../resource._entity._relations}}{{#equal _ent1.name ../../resource._entity.name}}{{#equal type 'm:m'}}
    let {{name}} = await result.get{{capitalize name}}({ raw: true });
    result.dataValues.{{name}} = {{name}}.map(item => item._id);
    {{/equal}}{{/equal}}{{/each}}
    {{#equal ../resource._entity.name "User"}}

    // Find roles
    let roles = await result.getRoles({ raw: true });
    result.dataValues.roles = roles.map(item => item.role);
    {{/equal}}
    return result;
  },
    {{/equal}}
    {{#equal crudAction 'update'}}

  /**
  * {{../resource.name}}Model.{{name}}{{#notEmpty description}}
  *   @description {{description}}{{/notEmpty}}{{#each _params}}
  *   @param {{type}} {{name}}{{#notEmpty description}} {{description}}{{/notEmpty}}{{/each}}{{#notEmpty returnType}}
  *   @returns {{returnType}}{{/notEmpty}}
  *
  */
  async {{name}}(item) { {{#equal ../resource._entity.name "User"}}
    delete item.password;
    {{/equal}}

    let result = await Database.getConnection().models.{{../resource.name}}.update(item, {
      where: { _id: item._id }
    });{{#each ../resource._entity._relations}}{{#equal _ent1.name ../../resource._entity.name}}{{#equal type 'm:m'}}
    result = await Database.getConnection().models.{{../../resource._entity.name}}.findByPk(item._id);
    let {{name}} = await result.set{{capitalize name}}(item.{{name}});
    result.{{name}} = {{name}};
    {{/equal}}{{/equal}}{{/each}}{{#equal ../resource._entity.name "User"}}
    // Update roles
    result = await Database.getConnection().models.User.findByPk(item._id);
    var roles = [];
    for (let i in item.roles) {
      let roleDb = await Database.getConnection().models.Roles.findOrCreate({
        where: {
          role: item.roles[i],
          _user: item._id
        }
      });
      roles.push(roleDb[0].dataValues._id);
    }

    result.setRoles(roles);{{/equal}}
    return result;
  },
    {{/equal}}
    {{#equal crudAction 'delete'}}

  /**
  * {{../resource.name}}Model.{{name}}{{#notEmpty description}}
  *   @description {{description}}{{/notEmpty}}{{#each _params}}
  *   @param {{type}} {{name}}{{#notEmpty description}} {{description}}{{/notEmpty}}{{/each}}{{#notEmpty returnType}}
  *   @returns {{returnType}}{{/notEmpty}}
  *
  */
  async {{name}}(id) {
    return await Database.getConnection().models.{{../resource.name}}.destroy({ where: { _id: id } });
  },
    {{/equal}}
    {{#equal crudAction 'create'}}

  /**
  * {{../resource.name}}Model.{{name}}{{#notEmpty description}}
  *   @description {{description}}{{/notEmpty}}{{#each _params}}
  *   @param {{type}} {{name}}{{#notEmpty description}} {{description}}{{/notEmpty}}{{/each}}{{#notEmpty returnType}}
  *   @returns {{returnType}}{{/notEmpty}}
  *
  */
  async {{name}}(item) {
    let result = await Database.getConnection().models.{{../resource.name}}.create(item);{{#each ../resource._entity._relations}}{{#equal _ent1.name ../../resource._entity.name}}{{#equal type 'm:m'}}
    let {{name}} = await result.set{{capitalize name}}(item.{{name}});
    result.{{name}} = {{name}};
    {{/equal}}{{/equal}}{{/each}}{{#equal ../resource._entity.name "User"}}

    // Create roles
    var roles = [];
    for (let i in item.roles) {
      let roleDb = await Database.getConnection().models.Roles.findOrCreate({
        where: {
          role: item.roles[i],
          _user: result._id
        }
      });
      roles.push(roleDb[0].dataValues._id);
    }

    result.setRoles(roles);
    {{/equal}}
    return result;
  },
    {{/equal}}
    {{#startWith crudAction 'findBy'}}

  /**
  * {{../resource.name}}Model.{{name}}{{#notEmpty description}}
  *   @description {{description}}{{/notEmpty}}{{#each _params}}
  *   @param {{type}} {{name}}{{#notEmpty description}} {{description}}{{/notEmpty}}{{/each}}{{#notEmpty returnType}}
  *   @returns {{returnType}}{{/notEmpty}}
  *
  */
  async {{name}}(key) {
    return await Database.getConnection().models.{{../resource.name}}.findAll({ where: { "{{#subStr name 6 }}{{/subStr}}": key } });
  },
    {{/startWith}}
    {{#startWith crudAction 'get'}}

  /**
  * {{../resource.name}}Model.{{name}}{{#notEmpty description}}
  *   @description {{description}}{{/notEmpty}}{{#each _params}}
  *   @param {{type}} {{name}}{{#notEmpty description}} {{description}}{{/notEmpty}}{{/each}}{{#notEmpty returnType}}
  *   @returns {{returnType}}{{/notEmpty}}
  *
  */
  async {{name}}(id) {
    return await Database.getConnection().models.{{../resource.name}}.findAll({ where: { {{#subStr name 3 }}{{/subStr}}: id } });
  },
    {{/startWith}}
  {{/each}}{{/notNull}}


  {{#equal resource._entity.name "User"}}

  // Start custom queries User

  /**
   * Get User by username e password
   */
  getByUsernameAndPassword: async (username, password) => {
    // CUSTOMIZE THIS FUNCTION
    // if you want to change login method

    let user = await Database.getConnection().models.User.findOne({
      where: {
        username: username,
        password: password
      },
      raw: true
    });
    if (user) {
      user.password = undefined;

      let roles = await Database.getConnection().models.Roles.findAll({
        where: {
          _user: user._id
        },
        raw: true
      });
      user.roles = roles.map(item => item.role);
    }

    return user;
  },

  /**
   * Update password
   */
  updatePassword: async (idUser, password) => {
    let user = await Database.getConnection().models.User.update(
      {
        password: password
      },
      {
        where: { _id: idUser }
      }
    );
    return user;
  },

  /**
   * Create ADMIN user if it not exists
   */
  createAdminUser: async () => {
    const count = await Database.getConnection().models.User.count();
    if (count == 0) {
      Logger.info("Create admin user");
      var admin = {
        username: "admin",
        password:
          "62f264d7ad826f02a8af714c0a54b197935b717656b80461686d450f7b3abde4c553541515de2052b9af70f710f0cd8a1a2d3f4d60aa72608d71a63a9a93c0f5",
        roles: ["ADMIN"]
      };
      let res = await Database.getConnection().models.User.create(admin);

      let role = {
        role: "ADMIN",
        _user: res._id
      };
      await Database.getConnection().models.Roles.create(role);
    }
  }
  {{/equal}}
};

export default generatedModel;
